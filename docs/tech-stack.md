# Tech Stack

## Обоснование выбора технологий

### Backend: Python + FastAPI

**Почему Python:**
- Отличная экосистема для работы с LLM (библиотеки для Scibox, OpenAI и др.)
- Простота интеграции с Docker для runner'а
- Быстрая разработка прототипа
- Хорошая поддержка асинхронности через asyncio

**Почему FastAPI:**
- Современный, быстрый фреймворк
- Автоматическая генерация OpenAPI документации
- Встроенная поддержка async/await
- Простая валидация через Pydantic
- Отличная производительность

**Альтернативы (не выбраны):**
- Django - слишком тяжёлый для прототипа
- Flask - менее современный, нет встроенной async поддержки
- Node.js - сложнее работать с LLM API

---

### Frontend: React + TypeScript

**Почему React:**
- Популярная и знакомая технология
- Большая экосистема компонентов
- Хорошая поддержка Monaco Editor
- Легко интегрировать чат и IDE

**Почему TypeScript:**
- Типобезопасность для больших проектов
- Лучший DX (автодополнение, рефакторинг)
- Меньше ошибок в рантайме

**Альтернативы (не выбраны):**
- Vue.js - менее популярен в команде
- Angular - слишком тяжёлый для прототипа
- Vanilla JS - слишком низкоуровнево

---

### IDE: Monaco Editor

**Почему Monaco:**
- Тот же редактор, что в VS Code
- Отличная поддержка синтаксиса (Python, JavaScript)
- Подсветка, автодополнение, ошибки
- Хорошая производительность
- Легко интегрируется с React

**Альтернативы (не выбраны):**
- CodeMirror - менее функциональный
- Ace Editor - устаревший
- Собственный редактор - слишком сложно для прототипа

---

### Code Runner: Docker

**Почему Docker:**
- Стандартная технология для изоляции кода
- Хорошая поддержка ограничений ресурсов
- Легко масштабировать
- Безопасность на уровне контейнеров

**Альтернативы (не выбраны):**
- Firecracker - слишком сложно для прототипа
- Sandboxed execution (gVisor) - избыточно для MVP
- Виртуальные машины - слишком медленно

---

### LLM: Scibox

**Почему Scibox:**
- Требование кейса
- API совместим с OpenAI
- Хорошее качество генерации кода и анализа

**Интеграция:**
- Используем библиотеку `openai` (совместима с Scibox)
- API ключ из переменной окружения `SCIBOX_API_KEY`
- Промпты хранятся в отдельном модуле для лёгкой настройки

---

### Database: PostgreSQL

**Почему PostgreSQL:**
- Надёжная реляционная БД
- Хорошая поддержка JSON для хранения задач и отчётов
- Отличная производительность
- Бесплатные варианты для демо (Supabase, Railway)

**Альтернативы (не выбраны):**
- MongoDB - избыточно для структурированных данных
- SQLite - не подходит для продакшена
- Redis - только для кэширования, не для основных данных

---

### Cache: Redis (опционально)

**Почему Redis:**
- Быстрое кэширование промптов и задач
- Хранение сессий
- Очереди для асинхронных задач

**Для демо можно обойтись без Redis**, используя in-memory кэш.

---

### Deployment

**Для демо:**
- Backend: Docker контейнер или напрямую через uvicorn
- Frontend: Статический build, раздача через nginx или Vercel/Netlify
- Database: Supabase (бесплатный PostgreSQL) или локально

**Для продакшена:**
- Kubernetes для оркестрации
- Отдельные сервисы для Backend, Runner, Frontend
- Managed PostgreSQL (AWS RDS, Google Cloud SQL)
- CDN для фронтенда

---

## Структура зависимостей

### Backend (requirements.txt):
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
openai==1.3.0  # для Scibox API
python-dotenv==1.0.0
docker==6.1.3
redis==5.0.1  # опционально
```

### Frontend (package.json):
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.2.2",
    "@monaco-editor/react": "^4.6.0",
    "axios": "^1.6.0",
    "react-markdown": "^9.0.0"
  }
}
```

---

## Принципы разработки

1. **Простота над сложностью**: Выбираем самое простое решение, которое работает
2. **Быстрый прототип**: Приоритет на рабочий демо, потом оптимизация
3. **Модульность**: Чёткое разделение слоёв (API, LLM, Runner)
4. **Конфигурация через env**: Все ключи и настройки через переменные окружения
5. **Документация**: Вся архитектура документирована в `docs/`

